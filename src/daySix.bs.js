// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var $$Array     = require("bs-platform/lib/js/array.js");
var Caml_obj    = require("bs-platform/lib/js/caml_obj.js");
var Caml_array  = require("bs-platform/lib/js/caml_array.js");
var Pervasives  = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

function max(numbers) {
  var match = $$Array.fold_left((function (param, n) {
          var index = param[2];
          var curMax = param[0];
          var match = +(curMax >= n);
          if (match !== 0) {
            return /* tuple */[
                    curMax,
                    param[1],
                    index + 1 | 0
                  ];
          } else {
            return /* tuple */[
                    n,
                    index,
                    index + 1 | 0
                  ];
          }
        }), /* tuple */[
        Caml_array.caml_array_get(numbers, 0),
        0,
        0
      ], numbers);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function print_list(_list) {
  while(true) {
    var list = _list;
    if (list) {
      Pervasives.print_int(list[0]);
      Pervasives.print_char(/* " " */32);
      _list = list[1];
      continue ;
      
    } else {
      return Pervasives.print_newline(/* () */0);
    }
  };
}

function reallocate(_banks, _blocksToAllocate, _start) {
  while(true) {
    var start = _start;
    var blocksToAllocate = _blocksToAllocate;
    var banks = _banks;
    var newAllocation = $$Array.copy(banks);
    var blocksLeft = blocksToAllocate;
    for(var index = start ,index_finish = newAllocation.length - 1 | 0; index <= index_finish; ++index){
      if (blocksLeft > 0) {
        Caml_array.caml_array_set(newAllocation, index, Caml_array.caml_array_get(newAllocation, index) + 1 | 0);
        blocksLeft = blocksLeft - 1 | 0;
      }
      
    }
    if (blocksLeft > 0) {
      _start = 0;
      _blocksToAllocate = blocksLeft;
      _banks = newAllocation;
      continue ;
      
    } else {
      return newAllocation;
    }
  };
}

function zeroIndex(index, array) {
  var newArr = $$Array.copy(array);
  Caml_array.caml_array_set(newArr, index, 0);
  return newArr;
}

function detectRepeat(allocations, newAllocation) {
  var match = $$Array.fold_left((function (param, oldAllocation) {
          var index = param[1];
          if (Caml_obj.caml_equal(oldAllocation, newAllocation)) {
            return /* tuple */[
                    index,
                    index + 1 | 0
                  ];
          } else {
            return /* tuple */[
                    param[0],
                    index + 1 | 0
                  ];
          }
        }), /* tuple */[
        -1,
        0
      ], allocations);
  var repeatIndex = match[0];
  if (repeatIndex > -1) {
    return /* tuple */[
            /* true */1,
            repeatIndex
          ];
  } else {
    return /* tuple */[
            /* false */0,
            repeatIndex
          ];
  }
}

function cycle(_banks, _allocations) {
  while(true) {
    var allocations = _allocations;
    var banks = _banks;
    var match = max(banks);
    var maxIndex = match[1];
    var newAllocation = reallocate(zeroIndex(maxIndex, banks), match[0], maxIndex + 1 | 0);
    var match$1 = detectRepeat(allocations, newAllocation);
    if (match$1[0]) {
      return /* tuple */[
              allocations,
              match$1[1]
            ];
    } else {
      _allocations = $$Array.concat(/* :: */[
            /* array */[newAllocation],
            /* :: */[
              allocations,
              /* [] */0
            ]
          ]);
      _banks = newAllocation;
      continue ;
      
    }
  };
}

function solve(input) {
  var banks = $$Array.map(Caml_format.caml_int_of_string, input.split(" "));
  var match = cycle(banks, /* array */[banks]);
  return match[0].length;
}

var Part1_000 = /* cases : :: */[
  /* tuple */[
    "0 2 7 0",
    5
  ],
  /* [] */0
];

var Part1 = /* module */[
  Part1_000,
  /* solve */solve
];

function solve$1(input) {
  var banks = $$Array.map(Caml_format.caml_int_of_string, input.split(" "));
  var match = cycle(banks, /* array */[banks]);
  return match[1] + 1 | 0;
}

var Part2_000 = /* cases : :: */[
  /* tuple */[
    "0 2 7 0",
    4
  ],
  /* [] */0
];

var Part2 = /* module */[
  Part2_000,
  /* solve */solve$1
];

var part1 = solve;

var part2 = solve$1;

exports.max          = max;
exports.print_list   = print_list;
exports.reallocate   = reallocate;
exports.zeroIndex    = zeroIndex;
exports.detectRepeat = detectRepeat;
exports.cycle        = cycle;
exports.Part1        = Part1;
exports.Part2        = Part2;
exports.part1        = part1;
exports.part2        = part2;
/* No side effect */
