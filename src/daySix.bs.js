// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List        = require("bs-platform/lib/js/list.js");
var $$Array     = require("bs-platform/lib/js/array.js");
var Caml_array  = require("bs-platform/lib/js/caml_array.js");
var Pervasives  = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

function max(list) {
  var match = List.fold_left((function (param, n) {
          var index = param[2];
          var curMax = param[0];
          var match = +(curMax >= n);
          if (match !== 0) {
            return /* tuple */[
                    curMax,
                    param[1],
                    index + 1 | 0
                  ];
          } else {
            return /* tuple */[
                    n,
                    index,
                    index + 1 | 0
                  ];
          }
        }), /* tuple */[
        List.hd(list),
        0,
        0
      ], list);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function print_list(_list) {
  while(true) {
    var list = _list;
    if (list) {
      Pervasives.print_int(list[0]);
      Pervasives.print_char(/* " " */32);
      _list = list[1];
      continue ;
      
    } else {
      return Pervasives.print_newline(/* () */0);
    }
  };
}

function reallocate(_banks, _blocksToAllocate, _start) {
  while(true) {
    var start = _start;
    var blocksToAllocate = _blocksToAllocate;
    var banks = _banks;
    var newAllocation = $$Array.copy(banks);
    var blocksLeft = blocksToAllocate;
    for(var index = start ,index_finish = newAllocation.length - 1 | 0; index <= index_finish; ++index){
      if (blocksLeft > 0) {
        Caml_array.caml_array_set(newAllocation, index, Caml_array.caml_array_get(newAllocation, index) + 1 | 0);
        blocksLeft = blocksLeft - 1 | 0;
      }
      
    }
    if (blocksLeft > 0) {
      _start = 0;
      _blocksToAllocate = blocksLeft;
      _banks = newAllocation;
      continue ;
      
    } else {
      return newAllocation;
    }
  };
}

function zeroIndex(index, array) {
  var newArr = $$Array.copy(array);
  Caml_array.caml_array_set(newArr, index, 0);
  return newArr;
}

function cycle(_banks, _allocations) {
  while(true) {
    var allocations = _allocations;
    var banks = _banks;
    var match = max(banks);
    var maxIndex = match[1];
    var newAllocation = $$Array.to_list(reallocate(zeroIndex(maxIndex, $$Array.of_list(banks)), match[0], maxIndex + 1 | 0));
    var isRepeat = List.exists((function(newAllocation){
        return function (oldAllocation) {
          return List.for_all2((function (a, b) {
                        return +(a === b);
                      }), newAllocation, oldAllocation);
        }
        }(newAllocation)), allocations);
    if (isRepeat) {
      return List.length(allocations) + 1 | 0;
    } else {
      _allocations = /* :: */[
        newAllocation,
        allocations
      ];
      _banks = newAllocation;
      continue ;
      
    }
  };
}

function solve(input) {
  var banks = $$Array.to_list($$Array.map(Caml_format.caml_int_of_string, input.split(" ")));
  return cycle(banks, /* [] */0);
}

var Part1_000 = /* cases : :: */[
  /* tuple */[
    "0 2 7 0",
    5
  ],
  /* [] */0
];

var Part1 = /* module */[
  Part1_000,
  /* reallocate */reallocate,
  /* zeroIndex */zeroIndex,
  /* cycle */cycle,
  /* solve */solve
];

function solve$1() {
  return 0;
}

var Part2 = /* module */[
  /* cases : [] */0,
  /* solve */solve$1
];

var part1 = solve;

exports.max        = max;
exports.print_list = print_list;
exports.Part1      = Part1;
exports.Part2      = Part2;
exports.part1      = part1;
/* No side effect */
