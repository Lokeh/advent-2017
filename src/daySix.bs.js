// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List        = require("bs-platform/lib/js/list.js");
var $$Array     = require("bs-platform/lib/js/array.js");
var Js_boolean  = require("bs-platform/lib/js/js_boolean.js");
var Pervasives  = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

function max(list) {
  var match = List.fold_left((function (param, n) {
          var index = param[2];
          var curMax = param[0];
          var match = +(curMax >= n);
          if (match !== 0) {
            return /* tuple */[
                    curMax,
                    param[1],
                    index + 1 | 0
                  ];
          } else {
            return /* tuple */[
                    n,
                    index,
                    index + 1 | 0
                  ];
          }
        }), /* tuple */[
        List.hd(list),
        0,
        0
      ], list);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function print_list(_list) {
  while(true) {
    var list = _list;
    if (list) {
      Pervasives.print_int(list[0]);
      Pervasives.print_char(/* " " */32);
      _list = list[1];
      continue ;
      
    } else {
      return Pervasives.print_newline(/* () */0);
    }
  };
}

function reallocate(banks, index, blocksToAllocate) {
  return List.fold_left((function (param, blocks) {
                  var curIndex = param[2];
                  var blocksLeft = param[1];
                  var banks = param[0];
                  console.log(/* tuple */[
                        blocks,
                        Js_boolean.to_js_boolean(+(curIndex === index)),
                        Js_boolean.to_js_boolean(+(blocksLeft > 0)),
                        blocks + 1 | 0
                      ]);
                  var match = +(curIndex === index);
                  var match$1 = +(blocksLeft > 0);
                  if (match !== 0) {
                    if (match$1 !== 0) {
                      return /* tuple */[
                              /* :: */[
                                1,
                                banks
                              ],
                              blocksLeft - 1 | 0,
                              curIndex + 1 | 0
                            ];
                    } else {
                      return /* tuple */[
                              /* :: */[
                                0,
                                banks
                              ],
                              blocksLeft,
                              curIndex + 1 | 0
                            ];
                    }
                  } else if (match$1 !== 0) {
                    return /* tuple */[
                            /* :: */[
                              blocks + 1 | 0,
                              banks
                            ],
                            blocksLeft - 1 | 0,
                            curIndex + 1 | 0
                          ];
                  } else {
                    return /* tuple */[
                            /* :: */[
                              blocks,
                              banks
                            ],
                            blocksLeft,
                            curIndex + 1 | 0
                          ];
                  }
                }), /* tuple */[
                /* [] */0,
                blocksToAllocate,
                0
              ], banks)[0];
}

function cycle(_banks, _allocations) {
  while(true) {
    var allocations = _allocations;
    var banks = _banks;
    var match = max(banks);
    print_list(banks);
    var newAllocation = reallocate(banks, match[1], match[0]);
    var isRepeat = List.exists((function(newAllocation){
        return function (oldAllocation) {
          return List.for_all2((function (a, b) {
                        return +(a === b);
                      }), newAllocation, oldAllocation);
        }
        }(newAllocation)), allocations);
    if (isRepeat) {
      return List.length(allocations);
    } else {
      _allocations = /* :: */[
        newAllocation,
        allocations
      ];
      _banks = newAllocation;
      continue ;
      
    }
  };
}

function solve(input) {
  var banks = $$Array.to_list($$Array.map(Caml_format.caml_int_of_string, input.split(" ")));
  return cycle(banks, /* [] */0);
}

var Part1_000 = /* cases : :: */[
  /* tuple */[
    "0 2 7 0",
    5
  ],
  /* [] */0
];

var Part1 = /* module */[
  Part1_000,
  /* reallocate */reallocate,
  /* cycle */cycle,
  /* solve */solve
];

function solve$1() {
  return 0;
}

var Part2 = /* module */[
  /* cases : [] */0,
  /* solve */solve$1
];

exports.max        = max;
exports.print_list = print_list;
exports.Part1      = Part1;
exports.Part2      = Part2;
/* No side effect */
