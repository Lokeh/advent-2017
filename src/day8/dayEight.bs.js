// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var $$Array                 = require("bs-platform/lib/js/array.js");
var Js_dict                 = require("bs-platform/lib/js/js_dict.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_format             = require("bs-platform/lib/js/caml_format.js");
var Js_primitive            = require("bs-platform/lib/js/js_primitive.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function max(numbers) {
  var match = $$Array.fold_left((function (param, n) {
          var index = param[2];
          var curMax = param[0];
          var match = +(curMax >= n);
          if (match !== 0) {
            return /* tuple */[
                    curMax,
                    param[1],
                    index + 1 | 0
                  ];
          } else {
            return /* tuple */[
                    n,
                    index,
                    index + 1 | 0
                  ];
          }
        }), /* tuple */[
        Caml_array.caml_array_get(numbers, 0),
        0,
        0
      ], numbers);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function unwrapRegisterValue(register) {
  if (register) {
    return register[0];
  } else {
    return 0;
  }
}

function assertPredicate(context, register, predicate, amount) {
  var value = unwrapRegisterValue(Js_primitive.undefined_to_opt(context[register]));
  switch (predicate) {
    case "!=" : 
        return +(value !== amount);
    case "<" : 
        return +(value < amount);
    case "<=" : 
        return +(value <= amount);
    case "==" : 
        return +(value === amount);
    case ">" : 
        return +(value > amount);
    case ">=" : 
        return +(value >= amount);
    default:
      throw [
            Caml_builtin_exceptions.failure,
            "Could not parse predicate"
          ];
  }
}

function executeOperation(context, register, op, amount) {
  var value = unwrapRegisterValue(Js_primitive.undefined_to_opt(context[register]));
  switch (op) {
    case "dec" : 
        return value - amount | 0;
    case "inc" : 
        return value + amount | 0;
    default:
      throw [
            Caml_builtin_exceptions.failure,
            "Could not parse operation"
          ];
  }
}

function solve(input) {
  var context = { };
  $$Array.iter((function (line) {
          if (line.length !== 7) {
            throw [
                  Caml_builtin_exceptions.failure,
                  "Could not parse register"
                ];
          } else {
            var opReg = line[0];
            var op = line[1];
            var amt = line[2];
            var match = line[3];
            if (match === "if") {
              var predReg = line[4];
              var pred = line[5];
              var predAmt = line[6];
              var amount = Caml_format.caml_int_of_string(amt);
              var predAmount = Caml_format.caml_int_of_string(predAmt);
              if (assertPredicate(context, predReg, pred, predAmount)) {
                context[opReg] = executeOperation(context, opReg, op, amount);
                return /* () */0;
              } else {
                return /* () */0;
              }
            } else {
              throw [
                    Caml_builtin_exceptions.failure,
                    "Could not parse register"
                  ];
            }
          }
        }), $$Array.map((function (param) {
              return param.split(" ");
            }), input.split("\n")));
  return max(Js_dict.values(context))[0];
}

var Part1_000 = /* cases : :: */[
  /* tuple */[
    "b inc 5 if a > 1\na inc 1 if b < 5\nc dec -10 if a >= 1\nc inc -20 if c == 10",
    1
  ],
  /* [] */0
];

var Part1 = /* module */[
  Part1_000,
  /* solve */solve
];

var Part2 = /* module */[];

var part1 = solve;

exports.max   = max;
exports.Part1 = Part1;
exports.Part2 = Part2;
exports.part1 = part1;
/* Js_dict Not a pure module */
