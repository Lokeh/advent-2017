// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Js_dict                 = require("bs-platform/lib/js/js_dict.js");
var Js_primitive            = require("bs-platform/lib/js/js_primitive.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function unwrapRegisterValue(register) {
  if (register) {
    return register[0];
  } else {
    return 0;
  }
}

function set(context, register) {
  return (function (param) {
      context[register] = param;
      return /* () */0;
    });
}

function get(context, register) {
  return unwrapRegisterValue(Js_primitive.undefined_to_opt(context[register]));
}

var values = Js_dict.values;

function make() {
  return { };
}

var Context = /* module */[
  /* unwrapRegisterValue */unwrapRegisterValue,
  /* set */set,
  /* get */get,
  /* values */values,
  /* make */make
];

function assertPredicate(context, register, predicate, amount) {
  var value = get(context, register);
  switch (predicate) {
    case "!=" : 
        return +(value !== amount);
    case "<" : 
        return +(value < amount);
    case "<=" : 
        return +(value <= amount);
    case "==" : 
        return +(value === amount);
    case ">" : 
        return +(value > amount);
    case ">=" : 
        return +(value >= amount);
    default:
      throw [
            Caml_builtin_exceptions.failure,
            "Could not parse predicate"
          ];
  }
}

function doOp(context, register, op, amount) {
  var value = get(context, register);
  switch (op) {
    case "dec" : 
        return value - amount | 0;
    case "inc" : 
        return value + amount | 0;
    default:
      throw [
            Caml_builtin_exceptions.failure,
            "Could not parse operation"
          ];
  }
}

exports.Context         = Context;
exports.assertPredicate = assertPredicate;
exports.doOp            = doOp;
/* Js_dict Not a pure module */
