// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var $$Array                 = require("bs-platform/lib/js/array.js");
var Caml_int32              = require("bs-platform/lib/js/caml_int32.js");
var Caml_format             = require("bs-platform/lib/js/caml_format.js");
var Utils$Advent2017        = require("./Utils.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function splitLines(input) {
  return $$Array.to_list(input.split("\n"));
}

function splitDigits(line) {
  return $$Array.to_list($$Array.map(Caml_format.caml_int_of_string, line.split(" ")));
}

function debug(input) {
  console.log(input);
  return input;
}

var cases = /* :: */[
  /* tuple */[
    "5 1 9 5\n7 5 3\n2 4 6 8",
    18
  ],
  /* [] */0
];

function minMax(param, z) {
  var y = param[1];
  var x = param[0];
  var match = +(z > x);
  var match$1 = +(z < y);
  if (match !== 0) {
    return /* tuple */[
            z,
            y
          ];
  } else if (match$1 !== 0) {
    return /* tuple */[
            x,
            z
          ];
  } else {
    return /* tuple */[
            x,
            y
          ];
  }
}

function lineMinMax(line) {
  if (line) {
    var hd = line[0];
    return List.fold_left(minMax, /* tuple */[
                hd,
                hd
              ], line[1]);
  } else {
    throw [
          Caml_builtin_exceptions.failure,
          "Empty line"
        ];
  }
}

function solve(input) {
  return List.fold_left((function (total, param) {
                return (total + param[0] | 0) - param[1] | 0;
              }), 0, List.map(lineMinMax, List.map(splitDigits, $$Array.to_list(input.split("\n")))));
}

var Part1 = /* module */[
  /* cases */cases,
  /* minMax */minMax,
  /* lineMinMax */lineMinMax,
  /* solve */solve
];

var Part1Test = Utils$Advent2017.Test([
      cases,
      solve
    ]);

var cases$1 = /* :: */[
  /* tuple */[
    "5 9 2 8\n9 4 7 3\n3 8 6 5",
    9
  ],
  /* [] */0
];

function hasDivisor(n, _digits) {
  while(true) {
    var digits = _digits;
    if (digits) {
      var m = digits[0];
      var match = +(Caml_int32.mod_(n, m) === 0);
      var match$1 = +(Caml_int32.mod_(m, n) === 0);
      if (match !== 0) {
        return /* Some */[/* tuple */[
                  n,
                  m
                ]];
      } else if (match$1 !== 0) {
        return /* Some */[/* tuple */[
                  m,
                  n
                ]];
      } else {
        _digits = digits[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function divisors(_digits) {
  while(true) {
    var digits = _digits;
    if (digits) {
      var rest = digits[1];
      var match = hasDivisor(digits[0], rest);
      if (match) {
        return match[0];
      } else {
        _digits = rest;
        continue ;
        
      }
    } else {
      throw [
            Caml_builtin_exceptions.failure,
            "No divisors found"
          ];
    }
  };
}

function solve$1(input) {
  return List.fold_left((function (total, param) {
                return total + Caml_int32.div(param[0], param[1]) | 0;
              }), 0, List.map(divisors, List.map(splitDigits, $$Array.to_list(input.split("\n")))));
}

var Part2 = /* module */[
  /* cases */cases$1,
  /* hasDivisor */hasDivisor,
  /* divisors */divisors,
  /* solve */solve$1
];

var Part2Test = Utils$Advent2017.Test([
      cases$1,
      solve$1
    ]);

var test_part1 = Part1Test[/* check */0];

var test_part2 = Part2Test[/* check */0];

var part1 = solve;

var part2 = solve$1;

exports.splitLines  = splitLines;
exports.splitDigits = splitDigits;
exports.debug       = debug;
exports.Part1       = Part1;
exports.Part1Test   = Part1Test;
exports.Part2       = Part2;
exports.Part2Test   = Part2Test;
exports.part1       = part1;
exports.test_part1  = test_part1;
exports.part2       = part2;
exports.test_part2  = test_part2;
/* Part1Test Not a pure module */
