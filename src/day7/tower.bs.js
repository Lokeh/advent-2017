// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var $$Array                 = require("bs-platform/lib/js/array.js");
var Js_option               = require("bs-platform/lib/js/js_option.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_format             = require("bs-platform/lib/js/caml_format.js");
var Js_primitive            = require("bs-platform/lib/js/js_primitive.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function sumArray(param) {
  return $$Array.fold_left((function (total, n) {
                return total + n | 0;
              }), 0, param);
}

var nameWeightRe = (/(.+) \((\d+)\)/);

function splitNames(array) {
  var len = array.length;
  if (len !== 1) {
    if (len !== 0) {
      throw [
            Caml_builtin_exceptions.failure,
            "Could not parse children names"
          ];
    } else {
      return /* None */0;
    }
  } else {
    var names = array[0];
    return /* Some */[names.split(", ")];
  }
}

function fromInput(input) {
  return input.split("\n").map((function (param) {
                  return param.split(" -> ");
                })).map((function (line) {
                var match = nameWeightRe.exec(Caml_array.caml_array_get(line, 0));
                if (match !== null) {
                  var name = Caml_array.caml_array_get(match, 1);
                  var weight = Caml_array.caml_array_get(match, 2);
                  if (name == null) {
                    throw [
                          Caml_builtin_exceptions.failure,
                          "Could not parse name and weight"
                        ];
                  } else if (weight == null) {
                    throw [
                          Caml_builtin_exceptions.failure,
                          "Could not parse name and weight"
                        ];
                  } else {
                    return /* record */[
                            /* name */name,
                            /* weight */Caml_format.caml_int_of_string(weight),
                            /* childrenNames */splitNames(line.slice(1))
                          ];
                  }
                } else {
                  throw [
                        Caml_builtin_exceptions.failure,
                        "Could not parse input"
                      ];
                }
              }));
}

function findRootDef(definitions, _currentDefIndex) {
  while(true) {
    var currentDefIndex = _currentDefIndex;
    var currentDef = Caml_array.caml_array_get(definitions, currentDefIndex);
    var currentName = currentDef[/* name */0];
    var parent = definitions.find((function(currentName){
        return function (def) {
          var match = def[/* childrenNames */2];
          if (match) {
            return Js_option.isSome(Js_primitive.undefined_to_opt(match[0].find((function (name) {
                                  return +(name === currentName);
                                }))));
          } else {
            return /* false */0;
          }
        }
        }(currentName)));
    if (parent !== undefined) {
      _currentDefIndex = currentDefIndex + 1 | 0;
      continue ;
      
    } else {
      return currentDef;
    }
  };
}

function findChildrenDefs(definitions, names) {
  return definitions.filter((function (def) {
                return +names.includes(def[/* name */0]);
              }));
}

var Definition = /* module */[
  /* fromInput */fromInput,
  /* findRootDef */findRootDef,
  /* findChildrenDefs */findChildrenDefs
];

function weigh(tower) {
  var match = tower[/* children */2];
  if (match) {
    return tower[/* weight */1] + $$Array.fold_left((function (total, weight) {
                  return total + weight | 0;
                }), 0, $$Array.map(weigh, match[0])) | 0;
  } else {
    return tower[/* weight */1];
  }
}

function isBalanced(weights) {
  return +weights.every((function (weight) {
                return +(weight === Caml_array.caml_array_get(weights, 0));
              }));
}

function make(definitions, root) {
  var match = root[/* childrenNames */2];
  if (match) {
    var children = $$Array.map((function (param) {
            return make(definitions, param);
          }), findChildrenDefs(definitions, match[0]));
    var weights = $$Array.map(weigh, children);
    return /* record */[
            /* name */root[/* name */0],
            /* weight */root[/* weight */1],
            /* children : Some */[children],
            /* isBalanced */isBalanced(weights),
            /* totalWeight */root[/* weight */1] + sumArray(weights) | 0
          ];
  } else {
    return /* record */[
            /* name */root[/* name */0],
            /* weight */root[/* weight */1],
            /* children : None */0,
            /* isBalanced : true */1,
            /* totalWeight */root[/* weight */1]
          ];
  }
}

exports.sumArray     = sumArray;
exports.nameWeightRe = nameWeightRe;
exports.splitNames   = splitNames;
exports.Definition   = Definition;
exports.weigh        = weigh;
exports.isBalanced   = isBalanced;
exports.make         = make;
/* nameWeightRe Not a pure module */
